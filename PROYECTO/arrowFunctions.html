<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="kube-6.0.1/dist/css/kube.css">
    <link rel="stylesheet" href="kube-6.0.1/dist/css/kube.min.css"> 
    <script src="kube-6.0.1/dist/js/kube.js"></script>
    <script src="kube-6.0.1/dist/js/kube.min.js"></script>
</head>
<body style="margin-left:25px;">
 <br>
    <h1 class="title text-center">EcmaScript 2015</h1>
<nav id="breadcrumb-custom-separator" class="breadcrumb centered">
    <ul>
        <li><em><a href="index.html">Inicio</a></em></li>
        <li class="active"><em><a href="arrowFunctions.html">Arrow Functions</a></em></li>
    </ul>
</nav>
   <h2 class="text-center">Arrow Functions</h2>
<blockquote >
    <p>Muchas veces tenemos funciones anidadas en las que queremos preservar el contexto de <Mark>this</Mark> desde su ámbito léxico. 
   </p>
</blockquote>
   <p>A continuación se muestra un ejemplo:</p>
  <pre>
function Person(name) {
    this.name = name;
}

Person.prototype.prefixName = function (arr) {
    return arr.map(function (character) {
        return this.name + character; // Cannot read property 'name' of undefined
    });
};

  </pre>
<p>Una solución común a este problema es almacenar el contexto de <Mark>this</Mark> usando una variable:</p>
<pre>
function Person(name) {
    this.name = name;
}

Person.prototype.prefixName = function (arr) {
    var that = this; // Store the context of this
    return arr.map(function (character) {
        return that.name + character;
    });
};

console.log(food); // Reference Error
</pre>

   <p>También podemos pasar en el contexto apropiado de <Mark>this</Mark>:</p>
   <pre>
function Person(name) {
    this.name = name;
}

Person.prototype.prefixName = function (arr) {
    return arr.map(function (character) {
        return this.name + character;
    }, this);
};
</pre>
<p>Además hay la posibilidad de vincular el contexto:</p>
<pre>
function Person(name) {
    this.name = name;
}

Person.prototype.prefixName = function (arr) {
    return arr.map(function (character) {
        return this.name + character;
    }.bind(this));
};
</pre>
<p>Usando <b>Arrow Functions</b>, el valor léxico de <Mark>this</Mark>no es sombreado y podemos volver a escribir lo anterior como se muestra:</p>

<pre>
function Person(name) {
    this.name = name;
}

Person.prototype.prefixName = function (arr) {
    return arr.map(character => this.name + character);
};
</pre>
<blockquote >
<b>Buena práctica:</b> usar <b>Arrow Functions</b> siempre que se necesite conservar el valor léxico de <Mark>this</Mark>.
</blockquote>
<p>Las Arrow Functions son más concisas cuando se usan en expresiones de funciones que simplemente devuelven un valor:</p>
<pre>
var squares = arr.map(function (x) { return x * x }); // Function Expression 
</pre>
<pre>
const arr = [1, 2, 3, 4, 5];
const squares = arr.map(x => x * x); // Arrow Function for terser implementation
</pre>

<blockquote><b>Buena práctica</b>: usar <b>Arrow Functions</b> en lugares de las expresiones de funciones cuando sea posible. </blockquote>
<nav id="breadcrumb-custom-separator" class="breadcrumb centered">
    <ul>
        <li><em><a href="index.html">Inicio</a></em></li>
        <li class="active"><em><a href="arrowFunctions.html">Arrow Functions</a></em></li>
    </ul>
</nav>
</body>
</html>